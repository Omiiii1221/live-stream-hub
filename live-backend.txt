================================================================================
LIVE STREAM HUB - BACKEND DOCUMENTATION
================================================================================

PROJECT STRUCTURE:
==================
Youtube/live-stream-hub/
├── src/
│   ├── components/          # React components
│   ├── pages/              # Page components (GoLive, Watch, Index)
│   ├── hooks/              # Custom hooks (useWebRTC.ts)
│   ├── data/               # Mock data (mockStreams.ts)
│   ├── types/              # TypeScript type definitions
│   └── lib/                # Utility functions
├── public/                 # Static assets
├── netlify/
│   └── functions/          # EMPTY - No serverless functions
├── package.json            # Frontend dependencies only
└── vite.config.ts          # Vite configuration

NO BACKEND DIRECTORIES FOUND:
- ❌ No server/ directory
- ❌ No api/ directory
- ❌ No backend/ directory
- ❌ No routes/ directory
- ❌ No models/ directory
- ❌ No controllers/ directory
- ❌ No middleware/ directory
- ❌ No database configuration
- ❌ No Express/Socket.IO server files
- ❌ No server-side package.json

TECHNOLOGY STACK:
=================
Frontend:
- React 18.3.1
- TypeScript 5.8.3
- Vite 7.3.0 (Build tool)
- React Router DOM 6.30.1
- PeerJS 1.5.5 (WebRTC library)
- Tailwind CSS 3.4.17
- shadcn/ui components

Backend:
- ❌ NO BACKEND SERVER
- ❌ NO Express.js
- ❌ NO Socket.IO server
- ❌ NO MongoDB/Database
- ❌ NO REST API
- ❌ NO Authentication server

ENVIRONMENT VARIABLES:
======================
N/A - No backend environment variables required.

The frontend runs entirely in the browser with no server-side dependencies.

================================================================================
ARCHITECTURE: HOW IT WORKS WITHOUT A BACKEND
================================================================================

This is a FRONTEND-ONLY application that uses Peer-to-Peer (P2P) WebRTC 
communication. Here's how it works:

1. PEER-TO-PEER ARCHITECTURE
   ========================
   - Uses PeerJS library for WebRTC peer-to-peer connections
   - Host and viewers connect directly to each other (no server in between)
   - PeerJS uses a public signaling server (peerjs.com) for initial connection
   - Once connected, media streams flow directly between peers

2. STREAMING FLOW
   ===============
   Host Side:
   - User clicks "Go Live" → Gets camera/screen media stream
   - Creates PeerJS peer with ID: `stream-host-${streamId}`
   - Waits for viewer connections
   - When viewer connects, answers call with media stream
   - Broadcasts chat messages to all connected viewers

   Viewer Side:
   - User visits `/watch/${streamId}`
   - Creates PeerJS peer with random ID: `viewer-${streamId}-${random}`
   - Connects to host peer: `stream-host-${streamId}`
   - Receives media stream directly from host
   - Sends chat messages to host, who broadcasts to all viewers

3. DATA STORAGE
   ============
   - ❌ NO DATABASE - All data is in-memory (client-side only)
   - Stream listings: Mock data in `src/data/mockStreams.ts`
   - Chat messages: Stored in React state (lost on refresh)
   - Viewer count: Calculated from active PeerJS connections
   - No persistence - everything is temporary

4. CHAT SYSTEM
   ===========
   - Chat messages sent via PeerJS DataConnection (peer-to-peer)
   - Host receives messages and broadcasts to all viewers
   - Messages stored only in browser memory (React state)
   - No message history persistence
   - No moderation or filtering

5. VIEWER COUNT
   =============
   - Calculated from active PeerJS MediaConnection count
   - Host tracks: `connectionsRef.current.size`
   - No server-side tracking
   - Count resets when host disconnects

================================================================================
KEY FILES EXPLAINING THE ARCHITECTURE
================================================================================

FILE 1: src/hooks/useWebRTC.ts
===============================
This is the CORE of the application - handles all WebRTC communication.

Key Functions:
- Creates PeerJS peer connections
- Manages media streams (video/audio)
- Handles chat messages via DataConnection
- Tracks viewer count
- Manages peer connections/disconnections

How it works:
1. Host creates peer with fixed ID: `stream-host-${streamId}`
2. Viewers create peer with random ID and connect to host
3. Host answers incoming calls with media stream
4. Chat messages sent via PeerJS DataConnection
5. All communication is peer-to-peer (no server)

FILE 2: src/data/mockStreams.ts
================================
Static mock data for stream listings.

- Hardcoded array of Stream objects
- Used only for display on homepage
- Not connected to actual streams
- No API calls to fetch real data

FILE 3: src/pages/GoLive.tsx
=============================
Host streaming interface.

- Gets user media (camera/screen)
- Uses useWebRTC hook to start broadcast
- Generates random streamId: `Math.random().toString(36).substr(2, 9)`
- Creates shareable URL: `${window.location.origin}/watch/${streamId}`
- No backend API calls

FILE 4: src/pages/Watch.tsx
============================
Viewer watching interface.

- Extracts streamId from URL params
- Uses useWebRTC hook to connect to host
- Displays remote media stream
- Shows chat messages
- No backend API calls

================================================================================
PEERJS SIGNALING SERVER
================================================================================

PeerJS uses a PUBLIC signaling server for initial peer discovery:
- Default: peerjs.com (free public server)
- Used ONLY for signaling (not media streaming)
- Media streams flow directly between peers after connection
- No custom signaling server in this project

To use a custom PeerJS server, you would need:
1. Run PeerJS server (separate Node.js application)
2. Configure PeerJS client to point to your server
3. Still no backend needed for your application logic

Current configuration in useWebRTC.ts:
```typescript
const newPeer = new Peer(peerId, { debug: 2 });
// Uses default peerjs.com signaling server
```

================================================================================
LIMITATIONS OF CURRENT ARCHITECTURE
================================================================================

1. NO PERSISTENCE
   - Stream data lost on page refresh
   - Chat messages not saved
   - No stream history
   - No user accounts

2. NO SCALABILITY
   - Host must maintain direct connection to each viewer
   - Limited by host's upload bandwidth
   - Not suitable for large audiences (100+ viewers)

3. NO AUTHENTICATION
   - Anyone can create a stream
   - No user accounts or permissions
   - No stream ownership

4. NO MODERATION
   - No chat moderation
   - No content filtering
   - No user blocking

5. NO ANALYTICS
   - No stream statistics
   - No viewer analytics
   - No performance metrics

6. MOCK DATA
   - Homepage shows hardcoded streams
   - Not connected to actual live streams
   - No discovery mechanism for active streams

================================================================================
WHAT WOULD BE NEEDED FOR A FULL BACKEND
================================================================================

To add a proper backend, you would need:

1. DATABASE (MongoDB/PostgreSQL)
   - User accounts
   - Stream records
   - Chat message history
   - Viewer analytics

2. REST API (Express.js)
   - User authentication (JWT)
   - Stream CRUD operations
   - Chat message storage
   - Stream discovery

3. SOCKET.IO SERVER
   - Real-time chat broadcasting
   - Viewer count updates
   - Stream status notifications
   - Better scalability than P2P

4. MEDIA SERVER (Optional)
   - RTMP server (for professional streaming)
   - HLS/DASH streaming
   - CDN integration
   - Better quality/bandwidth management

5. AUTHENTICATION
   - User registration/login
   - JWT tokens
   - Role-based access control
   - Stream ownership

6. FILE STORAGE
   - Thumbnail uploads
   - Profile pictures
   - Stream recordings (if needed)

================================================================================
PACKAGE.JSON ANALYSIS
================================================================================

File: package.json

{
  "name": "vite_react_shadcn_ts",
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",              // Frontend dev server only
    "build": "vite build",       // Frontend build only
    "preview": "vite preview"   // Frontend preview only
  },
  "dependencies": {
    // Frontend libraries only
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.30.1",
    "peerjs": "^1.5.5",          // WebRTC P2P library
    // UI components
    "@radix-ui/*": "...",
    // NO backend dependencies:
    // ❌ No express
    // ❌ No socket.io
    // ❌ No mongoose/mongodb
    // ❌ No jsonwebtoken
    // ❌ No bcrypt
  }
}

CONCLUSION: This is a frontend-only package.json with no backend dependencies.

================================================================================
NETLIFY FUNCTIONS DIRECTORY
================================================================================

Directory: netlify/functions/
Status: EMPTY - No serverless functions

If you wanted to add serverless functions, you would create:
- netlify/functions/streams.js
- netlify/functions/auth.js
- etc.

But currently, this directory is empty and unused.

================================================================================
API ENDPOINTS
================================================================================

N/A - No API endpoints exist.

The application makes NO HTTP requests to any backend API.

All communication is:
- Peer-to-peer via WebRTC (media streams)
- Peer-to-peer via PeerJS DataConnection (chat messages)
- Client-side only (React state management)

================================================================================
SOCKET.IO EVENTS
================================================================================

N/A - No Socket.IO server exists.

Chat communication uses:
- PeerJS DataConnection.send() to send messages
- PeerJS DataConnection.on('data') to receive messages
- Direct peer-to-peer communication

================================================================================
DATABASE SCHEMA
================================================================================

N/A - No database exists.

Data structures are TypeScript interfaces only:

File: src/types/index.ts

export interface Stream {
  id: string;
  title: string;
  description: string;
  hostId: string;
  hostName: string;
  hostAvatar?: string;
  status: 'scheduled' | 'live' | 'ended';
  thumbnailUrl?: string;
  viewerCount: number;
  startedAt?: Date;
  endedAt?: Date;
  createdAt: Date;
}

export interface ChatMessage {
  id: string;
  streamId: string;
  userId: string;
  username: string;
  message: string;
  timestamp: Date;
}

These are TypeScript types only - not database models.

================================================================================
SETUP INSTRUCTIONS
================================================================================

Current Setup (Frontend Only):
===============================

1. Install dependencies:
   ```bash
   npm install
   ```

2. Start development server:
   ```bash
   npm run dev
   ```

3. Open browser:
   - Frontend runs on http://localhost:5173 (Vite default)
   - No backend server needed
   - No database setup needed
   - No environment variables needed

4. How to use:
   - Go to /go-live to start streaming
   - Share the generated URL with viewers
   - Viewers go to /watch/{streamId} to watch

That's it! No backend setup required.

================================================================================
HOW TO ADD A BACKEND (IF NEEDED)
================================================================================

If you want to add a backend to this project, you would need to:

1. Create backend directory structure:
   ```
   backend/
   ├── server.js
   ├── routes/
   ├── models/
   ├── middleware/
   └── package.json
   ```

2. Install backend dependencies:
   ```bash
   cd backend
   npm install express socket.io mongoose jsonwebtoken bcryptjs
   ```

3. Create REST API endpoints for:
   - User authentication
   - Stream management
   - Chat message storage

4. Create Socket.IO server for:
   - Real-time chat
   - Viewer count updates

5. Set up MongoDB database

6. Update frontend to call API endpoints instead of using mock data

7. Replace PeerJS P2P chat with Socket.IO

However, the current implementation works WITHOUT any of this - it's 
completely frontend-only using peer-to-peer WebRTC.

================================================================================
SUMMARY
================================================================================

✅ CONFIRMED: This is a FRONTEND-ONLY project
✅ NO backend code exists in this repository
✅ Uses PeerJS for peer-to-peer WebRTC communication
✅ Uses mock data for stream listings
✅ Chat and streaming work entirely client-side
✅ No database, no API, no server-side code

The application works by:
1. Host creates WebRTC peer connection
2. Viewers connect directly to host via WebRTC
3. Media streams flow peer-to-peer
4. Chat messages sent peer-to-peer via DataConnection
5. Everything happens in the browser - no server needed

This architecture is suitable for:
- Small-scale streaming (few viewers)
- Prototyping and demos
- Learning WebRTC
- Simple peer-to-peer applications

Not suitable for:
- Production applications requiring persistence
- Large-scale streaming (100+ viewers)
- Applications needing user accounts
- Applications requiring moderation/analytics

================================================================================
END
================================================================================

